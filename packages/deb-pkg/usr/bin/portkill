#!/bin/bash

# PortKill - Advanced Port Management Tool
# Copyright (c) 2025 Abraham Esandayinze Tanta
# Licensed under MIT License

set -e

# Script metadata
readonly SCRIPT_NAME="PortKill"
readonly VERSION="3.0.0"
readonly AUTHOR="Abraham Esandayinze Tanta"
readonly CONFIG_DIR="$HOME/.portkill"
readonly LOG_FILE="$CONFIG_DIR/portkill.log"
readonly HISTORY_FILE="$CONFIG_DIR/history.log"
readonly WHITELIST_FILE="$CONFIG_DIR/whitelist.conf"
readonly CONFIG_FILE="$CONFIG_DIR/config.conf"

# Color definitions for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
# readonly MAGENTA='\033[0;35m' # Unused - disabled to avoid ShellCheck warning
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;90m'
readonly NC='\033[0m'
readonly BOLD='\033[1m'
# readonly DIM='\033[2m' # Unused - disabled to avoid ShellCheck warning

# Global variables
INTERACTIVE_MODE=false
VERBOSE_MODE=false
SAFE_MODE=true
AUTO_CONFIRM=false
SHOW_HEADERS=true
MONITORING_INTERVAL=2
HISTORY_LIMIT=50
# LAST_SCAN_TIME=0 # Reserved for future use - disabled to avoid ShellCheck warning

# Protected system processes
declare -a PROTECTED_PROCESSES=("launchd" "kernel_task" "systemstats" "sshd" "WindowServer" "loginwindow")

# Initialize configuration
init_config() {
    mkdir -p "$CONFIG_DIR"
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << EOF
# PortKill Configuration
safe_mode=true
auto_confirm=false
verbose_mode=false
monitoring_interval=2
max_history_entries=1000
enable_notifications=true
color_output=true
show_process_tree=true
EOF
    fi
    
    if [[ ! -f "$WHITELIST_FILE" ]]; then
        cat > "$WHITELIST_FILE" << EOF
# Protected processes (one per line)
launchd
kernel_task
systemstats
sshd
WindowServer
loginwindow
Finder
Dock
SystemUIServer
EOF
    fi
    
    # shellcheck source=/dev/null
    source "$CONFIG_FILE" 2>/dev/null || true
    
    while IFS= read -r line; do
        [[ "$line" =~ ^#.*$ ]] || [[ -z "$line" ]] && continue
        PROTECTED_PROCESSES+=("$line")
    done < "$WHITELIST_FILE" 2>/dev/null || true
}

# Logging functions
log_message() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    if [[ "$VERBOSE_MODE" == "true" ]]; then
        case "$level" in
            "ERROR") echo -e "${RED}[$level]${NC} $message" >&2 ;;
            "WARN")  echo -e "${YELLOW}[$level]${NC} $message" >&2 ;;
            "INFO")  echo -e "${CYAN}[$level]${NC} $message" >&2 ;;
            *) echo "[$level] $message" >&2 ;;
        esac
    fi
}

add_to_history() {
    local action="$1"
    local details="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "$timestamp|$action|$details" >> "$HISTORY_FILE"
    
    if [[ -f "$HISTORY_FILE" ]]; then
        tail -n 1000 "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
    fi
}

# Output functions
print_colored() {
    local color="$1"
    local icon="$2"
    local message="$3"
    local newline="${4:-true}"
    
    if [[ "$newline" == "true" ]]; then
        echo -e "${color}${icon} ${message}${NC}"
    else
        echo -ne "${color}${icon} ${message}${NC}"
    fi
}

show_progress_bar() {
    local current="$1"
    local total="$2"
    local width=50
    local percentage; percentage=$((current * 100 / total))
    local filled; filled=$((current * width / total))
    local empty; empty=$((width - filled))
    
    printf "\r%s[" "${BLUE}"
    printf "%*s" "$filled" "" | tr ' ' '='
    printf "%*s" "$empty" "" | tr ' ' '-'
    printf "] %d%% (%d/%d)%s" "$percentage" "$current" "$total" "${NC}"
}

# Header display
show_header() {
    if [[ "$SHOW_HEADERS" != "true" ]]; then return; fi
    
    clear
    echo -e "${CYAN}=================================================================================${NC}"
    echo -e "${CYAN}                              PortKill v${VERSION}                              ${NC}"
    echo -e "${CYAN}                     Advanced Port Management & Analysis                        ${NC}"
    echo -e "${CYAN}=================================================================================${NC}"
    echo
}

show_section_header() {
    local title="$1"
    echo
    echo -e "${BLUE}--- $title ---${NC}"
    echo
}

# Port validation
validate_port() {
    local port="$1"
    
    if [[ ! "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        print_colored "$RED" "[!]" "Invalid port number '$port' (must be 1-65535)"
        return 1
    fi
    
    return 0
}

# Parse port ranges (e.g., "3000-3005" -> "3000 3001 3002 3003 3004 3005")
parse_port_range() {
    local input="$1"
    local expanded_ports=()
    
    if [[ "$input" =~ ^([0-9]+)-([0-9]+)$ ]]; then
        local start_port="${BASH_REMATCH[1]}"
        local end_port="${BASH_REMATCH[2]}"
        
        if ! validate_port "$start_port" 2>/dev/null || ! validate_port "$end_port" 2>/dev/null; then
            print_colored "$RED" "[!]" "Invalid port range: $input"
            return 1
        fi
        
        if [ "$start_port" -gt "$end_port" ]; then
            print_colored "$RED" "[!]" "Invalid range: start port ($start_port) > end port ($end_port)"
            return 1
        fi
        
        if [ $((end_port - start_port)) -gt 100 ]; then
            print_colored "$RED" "[!]" "Port range too large (max 100 ports): $input"
            return 1
        fi
        
        for ((port=start_port; port<=end_port; port++)); do
            expanded_ports+=("$port")
        done
        
        echo "${expanded_ports[@]}"
        return 0
    else
        # Not a range, just validate single port
        if validate_port "$input" 2>/dev/null; then
            echo "$input"
            return 0
        else
            return 1
        fi
    fi
}

# Get service name for common ports
get_service_name() {
    local port="$1"
    
    case "$port" in
        22) echo "SSH" ;;
        25) echo "SMTP" ;;
        53) echo "DNS" ;;
        80) echo "HTTP" ;;
        110) echo "POP3" ;;
        143) echo "IMAP" ;;
        443) echo "HTTPS" ;;
        3000) echo "Dev Server" ;;
        3306) echo "MySQL" ;;
        5432) echo "PostgreSQL" ;;
        6379) echo "Redis" ;;
        8000|8080|8081) echo "HTTP Alt" ;;
        27017) echo "MongoDB" ;;
        *) echo "" ;;
    esac
}

# Find processes on port
find_processes_on_port() {
    local port="$1"
    local pids=""
    
    # Try lsof first (most reliable)
    if command -v lsof &> /dev/null; then
        pids=$(lsof -ti ":$port" 2>/dev/null || true)
    fi
    
    # Fallback to netstat
    if [[ -z "$pids" ]] && command -v netstat &> /dev/null; then
        pids=$(netstat -anv | grep ":$port " | awk '{print $9}' | cut -d'.' -f1 2>/dev/null || true)
    fi
    
    # Fallback to fuser
    if [[ -z "$pids" ]] && command -v fuser &> /dev/null; then
        pids=$(fuser "$port/tcp" 2>/dev/null | tr -s ' ' | cut -d' ' -f2- || true)
    fi
    
    if [[ -z "$pids" ]]; then
        return 1
    fi
    
    echo "$pids"
    return 0
}

# Get process information
get_process_info() {
    local pid="$1"
    local detailed="${2:-false}"
    
    if [[ ! "$pid" =~ ^[0-9]+$ ]]; then
        echo "Invalid PID"
        return 1
    fi
    
    if ! ps -p "$pid" > /dev/null 2>&1; then
        echo "Process not found"
        return 1
    fi
    
    if [[ "$detailed" == "true" ]]; then
        ps -p "$pid" -o pid=,ppid=,user=,pcpu=,pmem=,vsz=,rss=,tty=,stat=,start=,time=,comm= 2>/dev/null || echo "Error getting process info"
    else
        ps -p "$pid" -o user=,comm= 2>/dev/null || echo "unknown unknown"
    fi
}

# Get process command line
get_process_cmdline() {
    local pid="$1"
    
    if [[ -r "/proc/$pid/cmdline" ]]; then
        tr '\0' ' ' < "/proc/$pid/cmdline" 2>/dev/null
    else
        ps -p "$pid" -o args= 2>/dev/null || echo "N/A"
    fi
}

# Get parent PID of a process
get_parent_pid() {
    local pid="$1"
    
    # Try different methods to get PPID
    if [[ -r "/proc/$pid/stat" ]]; then
        awk '{print $4}' "/proc/$pid/stat" 2>/dev/null
    else
        ps -p "$pid" -o ppid= 2>/dev/null | tr -d ' '
    fi
}

# Get all child PIDs of a process
get_child_pids() {
    local parent_pid="$1"
    
    # Use pgrep if available, otherwise fallback to ps
    if command -v pgrep &> /dev/null; then
        pgrep -P "$parent_pid" 2>/dev/null || true
    else
        ps -eo pid,ppid | awk -v ppid="$parent_pid" '$2 == ppid {print $1}' 2>/dev/null || true
    fi
}

# Build process tree recursively
build_process_tree() {
    local pid="$1"
    local prefix="$2"
    local is_last="${3:-false}"
    local level="${4:-0}"
    local max_level="${5:-5}"
    
    # Prevent infinite recursion
    if [[ $level -gt $max_level ]]; then
        return
    fi
    
    # Get process info
    local info; info=$(get_process_info "$pid")
    local user; user=$(echo "$info" | awk '{print $1}')
    local command; command=$(echo "$info" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ $//')
    
    # Handle cases where process might not exist
    if [[ "$user" == "unknown" || -z "$command" ]]; then
        return
    fi
    
    # Choose the appropriate tree characters
    local tree_char="├──"
    local continuation="│   "
    if [[ "$is_last" == "true" ]]; then
        tree_char="└──"
        continuation="    "
    fi
    
    # Display current process
    local protection_status=""
    if is_protected_process "$command"; then
        protection_status="${RED}[PROTECTED]${NC} "
    fi
    
    printf "%s%s ${YELLOW}PID %s${NC} ${CYAN}(%s)${NC} ${WHITE}%s${NC} %s\n" \
        "$prefix" "$tree_char" "$pid" "$user" "$command" "$protection_status"
    
    # Get children
    local children; children=$(get_child_pids "$pid")
    if [[ -n "$children" ]]; then
        local child_array; read -ra child_array <<< "$children"
        local child_count=${#child_array[@]}
        
        for ((i=0; i<child_count; i++)); do
            local child_pid="${child_array[i]}"
            local is_last_child=false
            
            if [[ $((i + 1)) -eq $child_count ]]; then
                is_last_child=true
            fi
            
            build_process_tree "$child_pid" "$prefix$continuation" "$is_last_child" $((level + 1)) "$max_level"
        done
    fi
}

# Show process tree for port
show_process_tree() {
    local port="$1"
    local max_depth="${2:-5}"
    local pids
    
    if ! pids=$(find_processes_on_port "$port"); then
        print_colored "$YELLOW" "[i]" "No processes found on port $port"
        return 0
    fi
    
    local service_name; service_name=$(get_service_name "$port")
    if [[ -n "$service_name" ]]; then
        show_section_header "Process Tree for Port $port ($service_name)"
    else
        show_section_header "Process Tree for Port $port"
    fi
    
    print_colored "$CYAN" "[i]" "Showing process hierarchy (max depth: $max_depth)"
    echo
    
    # Build a complete process tree for each root process
    local processed_pids=()
    
    while read -r pid; do
        if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]]; then
            # Check if this PID is already processed as a child
            local already_processed=false
            for processed in "${processed_pids[@]}"; do
                if [[ "$processed" == "$pid" ]]; then
                    already_processed=true
                    break
                fi
            done
            
            if [[ "$already_processed" == "false" ]]; then
                # Find the root of this process tree
                local current_pid="$pid"
                local root_pid="$pid"
                local ancestors=()
                
                # Trace up to find root (but limit to prevent infinite loops)
                for ((i=0; i<10; i++)); do
                    local parent_pid; parent_pid=$(get_parent_pid "$current_pid")
                    
                    # If no parent or parent is init (PID 1) or launchd, we found the root
                    if [[ -z "$parent_pid" || "$parent_pid" -eq 1 || "$parent_pid" -eq 0 ]]; then
                        break
                    fi
                    
                    # Check if parent has any connection to our port (this prevents going too high)
                    if ! echo "$pids" | grep -q "$parent_pid"; then
                        # Parent not related to this port, current is the root for our tree
                        break
                    fi
                    
                    ancestors+=("$current_pid")
                    current_pid="$parent_pid"
                    root_pid="$parent_pid"
                done
                
                # Display tree starting from root
                echo -e "${BOLD}Process Tree:${NC}"
                build_process_tree "$root_pid" "" true 0 "$max_depth"
                
                # Mark all PIDs in this tree as processed
                processed_pids+=("$root_pid")
                processed_pids+=("${ancestors[@]}")
                
                # Add all descendants to processed list
                local all_descendants; all_descendants=$(get_all_descendants "$root_pid" 0 "$max_depth")
                if [[ -n "$all_descendants" ]]; then
                    read -ra desc_array <<< "$all_descendants"
                    processed_pids+=("${desc_array[@]}")
                fi
                
                echo
            fi
        fi
    done <<< "$pids"
    
    add_to_history "TREE" "Port: $port, Max depth: $max_depth"
}

# Get all descendants of a process (helper for marking processed PIDs)
get_all_descendants() {
    local pid="$1"
    local level="${2:-0}"
    local max_level="${3:-5}"
    local descendants=()
    
    if [[ $level -gt $max_level ]]; then
        return
    fi
    
    local children; children=$(get_child_pids "$pid")
    if [[ -n "$children" ]]; then
        local child_array; read -ra child_array <<< "$children"
        
        for child_pid in "${child_array[@]}"; do
            descendants+=("$child_pid")
            
            # Recursively get descendants
            local child_descendants; child_descendants=$(get_all_descendants "$child_pid" $((level + 1)) "$max_level")
            if [[ -n "$child_descendants" ]]; then
                read -ra child_desc_array <<< "$child_descendants"
                descendants+=("${child_desc_array[@]}")
            fi
        done
    fi
    
    echo "${descendants[@]}"
}

# Check if process is protected
is_protected_process() {
    local process_name="$1"
    
    for protected in "${PROTECTED_PROCESSES[@]}"; do
        if [[ "$process_name" == "$protected" ]]; then
            return 0
        fi
    done
    return 1
}

# List processes on port
list_processes() {
    local port="$1"
    local detailed="${2:-false}"
    local pids
    
    if ! pids=$(find_processes_on_port "$port"); then
        print_colored "$YELLOW" "[i]" "No processes found on port $port"
        return 0
    fi
    
    local service_name; service_name=$(get_service_name "$port")
    if [[ -n "$service_name" ]]; then
        print_colored "$BLUE" "[+]" "Port $port ($service_name) - Active Processes:"
    else
        print_colored "$BLUE" "[+]" "Port $port - Active Processes:"
    fi
    echo
    
    local count=0
    while read -r pid; do
        if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]]; then
            ((count++))
            
            if [[ "$detailed" == "true" ]]; then
                local proc_info; proc_info=$(get_process_info "$pid" "true")
                local cmdline; cmdline=$(get_process_cmdline "$pid")
                
                echo -e "  ${BOLD}Process #$count${NC}"
                echo -e "    PID: ${YELLOW}$pid${NC}"
                echo -e "    Info: $proc_info"
                echo -e "    Command: ${CYAN}$(echo "$cmdline" | cut -c1-80)${NC}"
                
                local comm; comm=$(echo "$proc_info" | awk '{print $NF}')
                if is_protected_process "$comm"; then
                    echo -e "    ${RED}[PROTECTED PROCESS]${NC}"
                fi
                echo
            else
                local info; info=$(get_process_info "$pid")
                local user; user=$(echo "$info" | awk '{print $1}')
                local command; command=$(echo "$info" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ $//')
                
                local protection_status=""
                if is_protected_process "$command"; then
                    protection_status="${RED}[PROTECTED]${NC}"
                fi
                
                printf "  ${YELLOW}%-8s${NC} ${CYAN}%-15s${NC} ${WHITE}%-30s${NC} %s\n" \
                    "PID $pid" "$user" "$command" "$protection_status"
            fi
        fi
    done <<< "$pids"
    
    if [[ $count -eq 0 ]]; then
        print_colored "$YELLOW" "[i]" "No valid processes found"
    else
        echo
        print_colored "$GREEN" "[i]" "Found $count process(es) on port $port"
    fi
}

# List all listening ports
list_all_listening_ports() {
    show_section_header "All Listening Ports"
    
    echo -e "${CYAN}Scanning for all listening ports...${NC}"
    echo
    
    local ports_info
    if command -v lsof &> /dev/null; then
        ports_info=$(lsof -i -P -n | grep LISTEN | sort -k9)
    else
        ports_info=$(netstat -an | grep LISTEN | sort)
    fi
    
    echo -e "${BOLD}${WHITE}Port     Service          PID      User         Process${NC}"
    echo -e "${GRAY}------------------------------------------------------------------------${NC}"
    
    local count=0
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            ((count++))
            
            local port; port=$(echo "$line" | awk '{print $9}' | cut -d':' -f2)
            local pid; pid=$(echo "$line" | awk '{print $2}')
            local user; user=$(echo "$line" | awk '{print $3}')
            local process; process=$(echo "$line" | awk '{print $1}')
            local service; service=$(get_service_name "$port")
            
            printf "%-8s %-15s %-8s %-12s %s\n" \
                "$port" "${service:-Unknown}" "$pid" "$user" "$process"
        fi
    done <<< "$ports_info"
    
    echo
    print_colored "$GREEN" "[i]" "Found $count listening port(s)"
}

# Kill processes on port
kill_processes() {
    local port="$1"
    local force="${2:-false}"
    local dry_run="${3:-false}"
    local interactive="${4:-false}"
    local pids
    local signal_name="SIGTERM"
    local signal_num=15
    local killed_count=0
    local failed_count=0
    
    if [[ "$force" == "true" ]]; then
        signal_name="SIGKILL"
        signal_num=9
    fi
    
    if ! pids=$(find_processes_on_port "$port"); then
        print_colored "$YELLOW" "[i]" "No processes found on port $port"
        return 0
    fi
    
    local service_name; service_name=$(get_service_name "$port")
    if [[ -n "$service_name" ]]; then
        print_colored "$BLUE" "[>]" "Port $port ($service_name) - Processing..."
    else
        print_colored "$BLUE" "[>]" "Port $port - Processing..."
    fi
    echo
    
    while read -r pid; do
        if [[ -n "$pid" && "$pid" =~ ^[0-9]+$ ]]; then
            local info; info=$(get_process_info "$pid")
            local user; user=$(echo "$info" | awk '{print $1}')
            local command; command=$(echo "$info" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ $//')
            
            if is_protected_process "$command" && [[ "$SAFE_MODE" == "true" ]]; then
                print_colored "$YELLOW" "[!]" "SKIPPED: Protected system process $command (PID $pid)"
                continue
            fi
            
            if [[ "$interactive" == "true" && "$AUTO_CONFIRM" != "true" ]]; then
                echo -ne "${WHITE}Kill process ${YELLOW}$pid${WHITE} (${CYAN}$command${WHITE}) with ${RED}$signal_name${WHITE}? (y/N/q): ${NC}"
                read -r response
                case "$response" in
                    [Yy]) ;;
                    [Qq]) print_colored "$GRAY" "[i]" "Operation cancelled"; return 0 ;;
                    *) print_colored "$GRAY" "[i]" "Skipped PID $pid"; continue ;;
                esac
            fi
            
            if [[ "$dry_run" == "true" ]]; then
                print_colored "$BLUE" "[i]" "DRY RUN: Would kill PID $pid ($command) on port $port with $signal_name"
                ((killed_count++))
            else
                if [[ "$signal_num" -eq 9 ]] || kill -TERM "$pid" 2>/dev/null; then
                    sleep 1
                    
                    if ps -p "$pid" > /dev/null 2>&1 && [[ "$signal_num" -eq 9 ]]; then
                        if kill -KILL "$pid" 2>/dev/null; then
                            print_colored "$RED" "[x]" "Force killed PID $pid ($command) on port $port"
                        else
                            print_colored "$RED" "[!]" "Failed to force kill PID $pid (may require sudo)"
                            ((failed_count++))
                            continue
                        fi
                    else
                        print_colored "$GREEN" "[✓]" "Terminated PID $pid ($command) on port $port"
                    fi
                    
                    ((killed_count++))
                    add_to_history "KILL" "Port: $port, PID: $pid, Process: $command, Signal: $signal_name"
                    log_message "INFO" "Killed process $pid ($command) on port $port with $signal_name"
                else
                    print_colored "$RED" "[!]" "Failed to kill PID $pid on port $port (may require sudo)"
                    ((failed_count++))
                fi
            fi
        fi
    done <<< "$pids"
    
    echo
    if [[ "$dry_run" == "true" ]]; then
        print_colored "$BLUE" "[i]" "DRY RUN: Would process $killed_count process(es) on port $port"
    else
        if [[ $killed_count -gt 0 ]]; then
            print_colored "$GREEN" "[✓]" "Successfully processed $killed_count process(es) on port $port"
        fi
        if [[ $failed_count -gt 0 ]]; then
            print_colored "$RED" "[!]" "Failed to process $failed_count process(es)"
        fi
    fi
}

# Bulk kill operation
bulk_kill_ports() {
    local ports=("$@")
    local total=${#ports[@]}
    local current=0
    
    show_section_header "Bulk Port Operation"
    
    print_colored "$CYAN" "[i]" "Processing $total port(s)..."
    echo
    
    for port in "${ports[@]}"; do
        ((current++))
        
        echo -ne "\r"
        show_progress_bar "$current" "$total"
        echo
        
        print_colored "$YELLOW" "[>]" "Processing port $port ($current/$total)..."
        kill_processes "$port" "$FORCE_MODE" "$DRY_RUN_MODE" "$INTERACTIVE_MODE"
        echo
        
        sleep 0.5
    done
    
    print_colored "$GREEN" "[✓]" "Bulk operation completed"
}

# Real-time port monitoring
monitor_ports() {
    local ports=("$@")
    local update_interval="${MONITORING_INTERVAL:-2}"
    
    show_header
    show_section_header "Real-time Port Monitoring"
    
    print_colored "$CYAN" "[i]" "Monitoring ${#ports[@]} port(s) - Press Ctrl+C to stop"
    echo -e "${GRAY}Update interval: ${update_interval}s${NC}"
    echo
    
    trap 'echo; print_colored "$YELLOW" "[i]" "Monitoring stopped"; exit 0' INT
    
    while true; do
        for ((i=0; i<20; i++)); do
            echo -e "\033[1A\033[2K"
        done
        
        echo -e "${BOLD}${WHITE}Port Status ($(date '+%H:%M:%S'))${NC}"
        echo -e "${GRAY}----------------------------------------${NC}"
        
        for port in "${ports[@]}"; do
            local pids
            if pids=$(find_processes_on_port "$port"); then
                local count; count=$(echo "$pids" | wc -w)
                local service; service=$(get_service_name "$port")
                if [[ -n "$service" ]]; then
                    print_colored "$GREEN" "[●]" "Port $port ($service): $count process(es) active"
                else
                    print_colored "$GREEN" "[●]" "Port $port: $count process(es) active"
                fi
                
                local first_pids; first_pids=$(echo "$pids" | tr ' ' '\n' | head -3 | tr '\n' ' ')
                echo -e "    ${GRAY}PIDs: $first_pids${NC}"
            else
                local service; service=$(get_service_name "$port")
                if [[ -n "$service" ]]; then
                    print_colored "$GRAY" "[○]" "Port $port ($service): No processes"
                else
                    print_colored "$GRAY" "[○]" "Port $port: No processes"
                fi
            fi
        done
        
        echo
        print_colored "$CYAN" "[↻]" "Next update in ${update_interval}s... (Ctrl+C to stop)"
        
        sleep "$update_interval"
    done
}

# Security scan for risky ports
security_scan() {
    show_section_header "Port Security Analysis"
    
    print_colored "$CYAN" "[i]" "Performing security analysis..."
    echo
    
    echo -e "${BOLD}${WHITE}Scanning for potentially risky open ports...${NC}"
    echo
    
    local risky_ports=(1433 3389 5900 5901 5902 21 23 135 139 445 1025 1433 1521 2049 3306 5432 6379 11211 27017)
    local found_risky=0
    
    for port in "${risky_ports[@]}"; do
        if find_processes_on_port "$port" >/dev/null 2>&1; then
            ((found_risky++))
            local service; service=$(get_service_name "$port")
            print_colored "$RED" "[!]" "SECURITY RISK: Port $port${service:+ ($service)} is open"
            
            local pids; pids=$(find_processes_on_port "$port")
            while read -r pid; do
                if [[ -n "$pid" ]]; then
                    local info; info=$(get_process_info "$pid")
                    local command; command=$(echo "$info" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i}')
                    echo -e "    ${GRAY}PID $pid: $command${NC}"
                fi
            done <<< "$pids"
            echo
        fi
    done
    
    if [[ $found_risky -eq 0 ]]; then
        print_colored "$GREEN" "[✓]" "No high-risk ports detected"
    else
        print_colored "$RED" "[!]" "Found $found_risky potentially risky open port(s)"
    fi
}

# Port history and analytics functions
show_port_history() {
    local limit="${1:-$HISTORY_LIMIT}"
    local format="${2:-table}"
    
    show_section_header "Port Usage History"
    
    if [[ ! -f "$HISTORY_FILE" ]]; then
        print_colored "$YELLOW" "[i]" "No history available yet"
        return
    fi
    
    if [[ "$format" == "csv" ]]; then
        echo "Timestamp,Action,Details"
        tail -n "$limit" "$HISTORY_FILE" | sort -r
        return
    fi
    
    print_colored "$CYAN" "[i]" "Showing last $limit history entries"
    echo
    
    printf "%-20s %-10s %-40s\n" "Timestamp" "Action" "Details"
    echo -e "${GRAY}────────────────────────────────────────────────────────────────────────${NC}"
    
    tail -n "$limit" "$HISTORY_FILE" | sort -r | while IFS='|' read -r timestamp action details; do
        local color="$CYAN"
        case "$action" in
            "KILL") color="$RED" ;;
            "LIST") color="$GREEN" ;;
            "SCAN") color="$BLUE" ;;
            "MONITOR") color="$YELLOW" ;;
        esac
        
        printf "${color}%-20s %-10s${NC} %-40s\n" "$timestamp" "$action" "$details"
    done
    
    echo
    print_colored "$GRAY" "[i]" "Use 'history --csv > file.csv' to export data"
}

show_port_analytics() {
    show_section_header "Port Usage Analytics"
    
    if [[ ! -f "$HISTORY_FILE" ]]; then
        print_colored "$YELLOW" "[i]" "No history data available for analytics"
        return
    fi
    
    local total_entries; total_entries=$(wc -l < "$HISTORY_FILE" 2>/dev/null || echo "0")
    print_colored "$CYAN" "[i]" "Analyzing $total_entries history entries"
    echo
    
    # Most active ports
    echo -e "${BOLD}${WHITE}Most Frequently Used Ports:${NC}"
    echo -e "${GRAY}────────────────────────────────${NC}"
    
    # Extract port numbers from history and count them
    if grep -E "Port: [0-9]+" "$HISTORY_FILE" | \
       sed -E 's/.*Port: ([0-9]+).*/\1/' | \
       sort | uniq -c | sort -rn | head -10 | \
       while read -r count port; do
           local service; service=$(get_service_name "$port")
           printf "${GREEN}%-4s${NC} Port %-5s %s\n" "$count" "$port" "${service:+($service)}"
       done; then
        true
    else
        print_colored "$GRAY" "[i]" "No port data found in history"
    fi
    
    echo
    
    # Action breakdown
    echo -e "${BOLD}${WHITE}Action Breakdown:${NC}"
    echo -e "${GRAY}──────────────────${NC}"
    
    # Count different actions
    cut -d'|' -f2 "$HISTORY_FILE" | sort | uniq -c | sort -rn | while read -r count action; do
        local color="$CYAN"
        case "$action" in
            "KILL") color="$RED" ;;
            "LIST") color="$GREEN" ;;
            "SCAN") color="$BLUE" ;;
            "MONITOR") color="$YELLOW" ;;
        esac
        
        printf "${color}%-10s${NC} %s operations\n" "$action" "$count"
    done
    
    echo
    
    # Recent activity (last 7 days)
    echo -e "${BOLD}${WHITE}Recent Activity (Last 7 Days):${NC}"
    echo -e "${GRAY}───────────────────────────────${NC}"
    
    local week_ago; week_ago=$(date -d '7 days ago' '+%Y-%m-%d' 2>/dev/null || date -v-7d '+%Y-%m-%d' 2>/dev/null)
    if [[ -n "$week_ago" ]]; then
        local recent_count; recent_count=$(awk -F'|' -v date="$week_ago" '$1 >= date' "$HISTORY_FILE" 2>/dev/null | wc -l)
        print_colored "$CYAN" "[●]" "$recent_count operations in the last week"
        
        # Today's activity
        local today; today=$(date '+%Y-%m-%d')
        local today_count; today_count=$(grep -c "^$today" "$HISTORY_FILE" 2>/dev/null || echo "0")
        print_colored "$GREEN" "[●]" "$today_count operations today"
    else
        print_colored "$YELLOW" "[i]" "Unable to calculate date ranges on this system"
    fi
}

clear_history() {
    local keep_entries="${1:-100}"
    
    if [[ ! -f "$HISTORY_FILE" ]]; then
        print_colored "$YELLOW" "[i]" "No history file to clear"
        return
    fi
    
    local current_entries; current_entries=$(wc -l < "$HISTORY_FILE" 2>/dev/null || echo "0")
    
    if [[ "$keep_entries" == "all" ]]; then
        true > "$HISTORY_FILE"
        print_colored "$GREEN" "[✓]" "All history entries cleared"
        add_to_history "ADMIN" "History cleared completely"
    else
        tail -n "$keep_entries" "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
        local remaining; remaining=$(wc -l < "$HISTORY_FILE" 2>/dev/null || echo "0")
        print_colored "$GREEN" "[✓]" "History trimmed: $current_entries → $remaining entries"
        add_to_history "ADMIN" "History trimmed to $remaining entries"
    fi
}

export_history() {
    local output_file="$1"
    local format="${2:-csv}"
    
    if [[ ! -f "$HISTORY_FILE" ]]; then
        print_colored "$RED" "[!]" "No history file found"
        return 1
    fi
    
    if [[ -z "$output_file" ]]; then
        output_file="portkill_history_$(date '+%Y%m%d_%H%M%S').$format"
    fi
    
    case "$format" in
        csv)
            {
                echo "Timestamp,Action,Details"
                sed 's/|/,/g' "$HISTORY_FILE"
            } > "$output_file"
            ;;
        json)
            {
                echo '['
                awk -F'|' 'BEGIN {first=1} 
                     {if(!first) print ","; first=0;
                      gsub(/"/, "\\""_, $3);
                      printf "{\"timestamp\":\"%s\",\"action\":\"%s\",\"details\":\"%s\"}", $1, $2, $3}' "$HISTORY_FILE"
                printf '\n]\n'
            } > "$output_file"
            ;;
        *)
            cp "$HISTORY_FILE" "$output_file"
            ;;
    esac
    
    print_colored "$GREEN" "[✓]" "History exported to: $output_file"
    add_to_history "EXPORT" "History exported to $output_file ($format format)"
}

# Interactive menu
show_main_menu() {
    show_header
    
    echo -e "${GREEN}Main Menu${NC}"
    echo -e "${GRAY}----------------------------------------${NC}"
    echo
    echo "  1) List processes on a port"
    echo "  2) List all listening ports"
    echo "  3) Kill processes on a port"
    echo "  4) Kill processes on multiple ports"
    echo "  5) Monitor ports in real-time"
    echo "  6) Security scan"
    echo "  7) Show process tree for port"
    echo "  8) Port performance benchmark"
    echo "  9) View operation history"
    echo "  10) Port usage analytics"
    echo "  11) Export history data"
    echo "  0) Exit"
    echo
}

interactive_menu() {
    while true; do
        show_main_menu
        
        echo -ne "${WHITE}Select an option (0-11): ${NC}"
        read -r choice
        
        case "$choice" in
            1)
                echo -ne "${WHITE}Enter port number: ${NC}"
                read -r port
                if validate_port "$port"; then
                    list_processes "$port" false
                    add_to_history "LIST" "Port: $port"
                fi
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            2)
                list_all_listening_ports
                add_to_history "SCAN" "Listed all listening ports"
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            3)
                echo -ne "${WHITE}Enter port number: ${NC}"
                read -r port
                if validate_port "$port"; then
                    echo -ne "${WHITE}Use force kill? (y/N): ${NC}"
                    read -r force
                    [[ "$force" =~ ^[Yy]$ ]] && force=true || force=false
                    
                    kill_processes "$port" "$force" false true
                fi
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            4)
                echo -ne "${WHITE}Enter ports (space-separated): ${NC}"
                read -r -a ports
                if [[ ${#ports[@]} -gt 0 ]]; then
                    bulk_kill_ports "${ports[@]}"
                fi
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            5)
                echo -ne "${WHITE}Enter ports to monitor (space-separated): ${NC}"
                read -r -a ports
                if [[ ${#ports[@]} -gt 0 ]]; then
                    monitor_ports "${ports[@]}"
                fi
                ;;
            6)
                security_scan
                add_to_history "SCAN" "Security scan performed"
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            7)
                echo -ne "${WHITE}Enter port number: ${NC}"
                read -r port
                if validate_port "$port"; then
                    echo -ne "${WHITE}Max tree depth [5]: ${NC}"
                    read -r depth
                    depth="${depth:-5}"
                    show_process_tree "$port" "$depth"
                fi
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            8)
                echo -ne "${WHITE}Enter port number: ${NC}"
                read -r port
                if validate_port "$port"; then
                    echo -ne "${WHITE}Enter host [localhost]: ${NC}"
                    read -r host
                    host="${host:-localhost}"
                    echo -ne "${WHITE}Number of tests [10]: ${NC}"
                    read -r test_count
                    test_count="${test_count:-10}"
                    benchmark_port "$port" "$host" "$test_count"
                fi
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            9)
                show_port_history
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            10)
                show_port_analytics
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            11)
                echo -ne "${WHITE}Export format (csv/json/raw) [csv]: ${NC}"
                read -r format
                format="${format:-csv}"
                echo -ne "${WHITE}Output filename (optional): ${NC}"
                read -r filename
                export_history "$filename" "$format"
                echo -ne "${GRAY}Press Enter to continue...${NC}"
                read -r
                ;;
            0)
                print_colored "$GREEN" "[✓]" "Exiting PortKill"
                exit 0
                ;;
            *)
                print_colored "$RED" "[!]" "Invalid option. Please try again."
                sleep 1
                ;;
        esac
    done
}

# Port benchmark and performance testing
benchmark_port() {
    local port="$1"
    local host="${2:-localhost}"
    local test_count="${3:-10}"
    local concurrent_tests="${4:-5}"
    local timeout_seconds="${5:-5}"
    
    if ! validate_port "$port"; then
        return 1
    fi
    
    show_section_header "Port Performance Benchmark - $host:$port"
    
    # Helper function for high-precision timestamps
    get_timestamp() {
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if command -v python3 &> /dev/null; then
                python3 -c "import time; print(f'{time.time():.3f}')"
            else
                date +%s
            fi
        else
            date +%s.%3N
        fi
    }
    
    print_colored "$CYAN" "[i]" "Starting benchmark with $test_count tests ($concurrent_tests concurrent)"
    print_colored "$CYAN" "[i]" "Timeout: ${timeout_seconds}s per test"
    echo
    
    local start_time; start_time=$(get_timestamp)
    local success_count=0
    local total_response_time=0
    local min_time=999999
    local max_time=0
    local response_times=()
    
    # Test if port is actually listening
    print_colored "$BLUE" "[~]" "Checking if port $port is accessible..."
    
    # Function to run command with timeout (macOS compatible)
    run_with_timeout() {
        local timeout_duration="$1"
        shift
        
        if command -v timeout &> /dev/null; then
            # GNU timeout (Linux)
            timeout "$timeout_duration" "$@"
        elif command -v gtimeout &> /dev/null; then
            # GNU timeout via Homebrew (macOS)
            gtimeout "$timeout_duration" "$@"
        else
            # Fallback: use background process and kill
            "$@" &
            local pid=$!
            (
                sleep "$timeout_duration"
                kill "$pid" 2>/dev/null
            ) &
            local killer_pid=$!
            
            if wait "$pid" 2>/dev/null; then
                kill "$killer_pid" 2>/dev/null
                return 0
            else
                kill "$killer_pid" 2>/dev/null
                return 1
            fi
        fi
    }
    
    if command -v nc &> /dev/null; then
        if run_with_timeout "$timeout_seconds" nc -z "$host" "$port" 2>/dev/null; then
            print_colored "$GREEN" "[✓]" "Port $port is accessible on $host"
        else
            print_colored "$RED" "[!]" "Port $port is not accessible on $host"
            return 1
        fi
    elif command -v telnet &> /dev/null; then
        if run_with_timeout "$timeout_seconds" bash -c "echo '' | telnet $host $port" &>/dev/null; then
            print_colored "$GREEN" "[✓]" "Port $port is accessible on $host"
        else
            print_colored "$RED" "[!]" "Port $port is not accessible on $host"
            return 1
        fi
    else
        print_colored "$YELLOW" "[!]" "nc or telnet not found - skipping port accessibility check"
    fi
    
    echo
    print_colored "$BLUE" "[~]" "Running performance tests..."
    
    # Function to test a single connection
    test_connection() {
        local test_start; test_start=$(get_timestamp)
        
        if command -v nc &> /dev/null; then
            if run_with_timeout "$timeout_seconds" nc -z "$host" "$port" 2>/dev/null; then
                local test_end; test_end=$(get_timestamp)
                local response_time; response_time=$(echo "$test_end - $test_start" | bc -l 2>/dev/null || echo "scale=3; $test_end - $test_start" | bc)
                echo "$response_time"
                return 0
            fi
        elif command -v telnet &> /dev/null; then
            if run_with_timeout "$timeout_seconds" bash -c "echo '' | telnet $host $port" &>/dev/null; then
                local test_end; test_end=$(get_timestamp)
                local response_time; response_time=$(echo "$test_end - $test_start" | bc -l 2>/dev/null || echo "scale=3; $test_end - $test_start" | bc)
                echo "$response_time"
                return 0
            fi
        fi
        
        return 1
    }
    
    # Run concurrent tests
    local batch_size="$concurrent_tests"
    local completed=0
    
    for ((batch_start=0; batch_start<test_count; batch_start+=batch_size)); do
        local batch_end=$((batch_start + batch_size))
        if [[ $batch_end -gt $test_count ]]; then
            batch_end=$test_count
        fi
        
        local pids=()
        local temp_files=()
        
        # Start concurrent tests
        for ((i=batch_start; i<batch_end; i++)); do
            local temp_file; temp_file=$(mktemp)
            temp_files+=("$temp_file")
            
            (
                if result=$(test_connection); then
                    echo "SUCCESS:$result" > "$temp_file"
                else
                    echo "FAILURE" > "$temp_file"
                fi
            ) &
            
            pids+=("$!")
        done
        
        # Wait for batch to complete
        for pid in "${pids[@]}"; do
            wait "$pid"
        done
        
        # Process results
        for temp_file in "${temp_files[@]}"; do
            local result; result=$(cat "$temp_file")
            rm -f "$temp_file"
            
            if [[ "$result" =~ ^SUCCESS:(.+)$ ]]; then
                local response_time="${BASH_REMATCH[1]}"
                ((success_count++))
                response_times+=("$response_time")
                
                # Use bc if available for floating point arithmetic
                if command -v bc &> /dev/null; then
                    total_response_time=$(echo "$total_response_time + $response_time" | bc -l)
                    if (( $(echo "$response_time < $min_time" | bc -l) )); then
                        min_time="$response_time"
                    fi
                    if (( $(echo "$response_time > $max_time" | bc -l) )); then
                        max_time="$response_time"
                    fi
                else
                    # Fallback to integer arithmetic (multiply by 1000 for milliseconds)
                    local int_response_time; int_response_time=$(echo "$response_time * 1000" | cut -d'.' -f1)
                    local int_total; int_total=$(echo "$total_response_time * 1000" | cut -d'.' -f1)
                    int_total=$((int_total + int_response_time))
                    total_response_time=$(echo "scale=3; $int_total / 1000" | bc -l 2>/dev/null || echo "$int_total")
                fi
            fi
            
            ((completed++))
            show_progress_bar "$completed" "$test_count"
        done
    done
    
    echo
    echo
    
    local end_time; end_time=$(get_timestamp)
    local total_test_time
    if command -v bc &> /dev/null; then
        total_test_time=$(echo "$end_time - $start_time" | bc -l)
    else
        total_test_time=$(echo "scale=3; $end_time - $start_time" | bc)
    fi
    
    # Display results
    show_section_header "Benchmark Results"
    
    echo -e "${BOLD}Test Configuration:${NC}"
    echo -e "  Target: ${CYAN}$host:$port${NC}"
    echo -e "  Tests: ${YELLOW}$test_count${NC} (${YELLOW}$concurrent_tests${NC} concurrent)"
    echo -e "  Timeout: ${YELLOW}${timeout_seconds}s${NC} per test"
    echo
    
    echo -e "${BOLD}Connection Results:${NC}"
    echo -e "  Successful: ${GREEN}$success_count${NC}/$test_count ($(echo "scale=1; $success_count * 100 / $test_count" | bc)%)"
    echo -e "  Failed: ${RED}$((test_count - success_count))${NC}/$test_count ($(echo "scale=1; (100 - ($success_count * 100 / $test_count))" | bc)%)"
    echo
    
    if [[ $success_count -gt 0 ]]; then
        local avg_time
        if command -v bc &> /dev/null; then
            avg_time=$(echo "scale=3; $total_response_time / $success_count" | bc -l)
        else
            avg_time=$(echo "$total_response_time / $success_count" | bc)
        fi
        
        echo -e "${BOLD}Response Time Statistics:${NC}"
        echo -e "  Average: ${CYAN}${avg_time}s${NC} ($(echo "$avg_time * 1000" | bc | cut -d'.' -f1)ms)"
        echo -e "  Minimum: ${GREEN}${min_time}s${NC} ($(echo "$min_time * 1000" | bc | cut -d'.' -f1)ms)"
        echo -e "  Maximum: ${RED}${max_time}s${NC} ($(echo "$max_time * 1000" | bc | cut -d'.' -f1)ms)"
        echo
        
        # Calculate percentiles if we have enough data
        if [[ ${#response_times[@]} -ge 5 ]]; then
            local sorted_times
            mapfile -t sorted_times < <(printf '%s\n' "${response_times[@]}" | sort -n)
            
            local p50_index=$(( ${#sorted_times[@]} * 50 / 100 ))
            local p95_index=$(( ${#sorted_times[@]} * 95 / 100 ))
            local p99_index=$(( ${#sorted_times[@]} * 99 / 100 ))
            
            echo -e "${BOLD}Percentiles:${NC}"
            echo -e "  50th: ${CYAN}${sorted_times[$p50_index]}s${NC}"
            [[ $p95_index -lt ${#sorted_times[@]} ]] && echo -e "  95th: ${YELLOW}${sorted_times[$p95_index]}s${NC}"
            [[ $p99_index -lt ${#sorted_times[@]} ]] && echo -e "  99th: ${RED}${sorted_times[$p99_index]}s${NC}"
            echo
        fi
    fi
    
    echo -e "${BOLD}Performance Metrics:${NC}"
    if command -v bc &> /dev/null; then
        local requests_per_second; requests_per_second=$(echo "scale=2; $success_count / $total_test_time" | bc -l)
        echo -e "  Throughput: ${GREEN}${requests_per_second}${NC} successful connections/sec"
    fi
    echo -e "  Total Test Time: ${CYAN}${total_test_time}s${NC}"
    echo
    
    # Performance assessment
    if [[ $success_count -eq $test_count ]]; then
        if command -v bc &> /dev/null && (( $(echo "$avg_time < 0.1" | bc -l) )); then
            print_colored "$GREEN" "[✓]" "Excellent performance: All tests passed with avg response < 100ms"
        elif command -v bc &> /dev/null && (( $(echo "$avg_time < 1.0" | bc -l) )); then
            print_colored "$GREEN" "[✓]" "Good performance: All tests passed with avg response < 1s"
        else
            print_colored "$YELLOW" "[!]" "Moderate performance: All tests passed but response time is slow"
        fi
    elif [[ $success_count -gt $((test_count * 8 / 10)) ]]; then
        print_colored "$YELLOW" "[!]" "Acceptable performance: Most tests passed (>80%)"
    else
        print_colored "$RED" "[!]" "Poor performance: Many connection failures (<80% success)"
    fi
    
    add_to_history "BENCHMARK" "Port: $port, Host: $host, Tests: $test_count, Success: $success_count/$test_count"
}

# Help documentation
show_help() {
    echo -e "${BOLD}$SCRIPT_NAME $VERSION${NC}"
    echo "Advanced Port Management & Network Analysis"
    echo
    echo "USAGE:"
    echo "  $0 [OPTIONS] [PORTS...]        Kill processes on ports (default)"
    echo "  $0 [OPTIONS] [COMMAND] [PORTS...]"
    echo
    echo "COMMANDS:"
    echo "  list     [-d] <port>           List processes on port(s)"
    echo "  kill     [-f] [-n] <port>      Kill processes on port(s)"
    echo "  monitor  <ports>               Real-time monitoring"
    echo "  tree     [--depth N] <port>    Show process tree hierarchy"
    echo "  scan     [--security]          Scan ports or security"
    echo "  benchmark <port> [host]        Performance test port connections"
    echo "  history  [--csv] [--analytics] View port usage history & analytics"
    echo "  menu                           Interactive menu mode"
    echo
    echo "OPTIONS:"
    echo "  -f, --force           Use SIGKILL instead of SIGTERM"
    echo "  -d, --detailed        Show detailed process information"
    echo "  -n, --dry-run         Show what would be done without doing it"
    echo "  -i, --interactive     Interactive confirmation for each process"
    echo "  -v, --verbose         Verbose output with logging"
    echo "  -q, --quiet           Suppress headers and decorative output"
    echo "  -s, --safe            Safe mode (protect system processes)"
    echo "  --version             Show version information"
    echo "  --help                Show this help message"
    echo
    echo "EXAMPLES:"
    echo "  $0 3000                       # Kill processes on port 3000"
    echo "  $0 3000 8080 9000             # Kill processes on multiple ports"
    echo "  $0 3000-3005                  # Kill processes on port range 3000-3005"
    echo "  $0 -f 3000                    # Force kill processes on port 3000"
    echo "  $0 -i 8080                    # Interactive kill for port 8080"
    echo "  $0 list 3000                  # List processes on port 3000"
    echo "  $0 tree 3000                  # Show process tree for port 3000"
    echo "  $0 tree --depth 3 8080        # Show process tree with max depth 3"
    echo "  $0 monitor 3000 8080          # Monitor ports in real-time"
    echo "  $0 scan --security            # Security scan"
    echo "  $0 benchmark 3000             # Performance test port 3000"
    echo "  $0 benchmark 80 google.com    # Test remote port performance"
    echo "  $0 history                    # View port usage history"
    echo "  $0 history --analytics        # Show port usage analytics"
    echo "  $0 menu                       # Interactive menu mode"
}

show_version() {
    echo "$SCRIPT_NAME $VERSION"
    echo "Copyright (c) 2025 $AUTHOR"
    echo "Licensed under MIT License"
}

# Main function
main() {
    init_config
    log_message "INFO" "PortKill $VERSION started"
    
    local ports=()
    local command=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            --verbose|-v)
                VERBOSE_MODE=true
                shift
                ;;
            --quiet|-q)
                SHOW_HEADERS=false
                VERBOSE_MODE=false
                shift
                ;;
            --safe|-s)
                SAFE_MODE=true
                shift
                ;;
            --force|-f)
                FORCE_MODE=true
                shift
                ;;
            --dry-run|-n)
                DRY_RUN_MODE=true
                shift
                ;;
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            --detailed|-d)
                DETAILED_MODE=true
                shift
                ;;
            -l|--list)
                command="list"
                shift
                ;;
            tree)
                command="$1"
                shift
                # Process tree-specific options
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --depth)
                            shift
                            if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
                                TREE_DEPTH="$1"
                                shift
                            else
                                print_colored "$RED" "[!]" "--depth requires a numeric value"
                                exit 1
                            fi
                            ;;
                        --*)
                            print_colored "$RED" "[!]" "Unknown tree option: $1"
                            exit 1
                            ;;
                        *)
                            break
                            ;;
                    esac
                done
                break
                ;;
            list|kill|monitor|menu)
                command="$1"
                shift
                break
                ;;
            scan)
                command="$1"
                shift
                if [[ "$1" == "--security" ]]; then
                    SECURITY_SCAN=true
                    shift
                fi
                break
                ;;
            benchmark)
                command="$1"
                shift
                break
                ;;
            history)
                command="$1"
                shift
                # Process history options
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --csv)
                            HISTORY_FORMAT="csv"
                            shift
                            ;;
                        --analytics)
                            HISTORY_ANALYTICS=true
                            shift
                            ;;
                        --export)
                            HISTORY_EXPORT=true
                            shift
                            [[ $# -gt 0 && ! "$1" =~ ^-- ]] && { HISTORY_EXPORT_FORMAT="$1"; shift; }
                            ;;
                        --clear)
                            HISTORY_CLEAR=true
                            shift
                            [[ $# -gt 0 && ! "$1" =~ ^-- ]] && { HISTORY_KEEP="$1"; shift; }
                            ;;
                        --*)
                            print_colored "$RED" "[!]" "Unknown history option: $1"
                            exit 1
                            ;;
                        *)
                            if [[ "$1" =~ ^[0-9]+$ ]]; then
                                HISTORY_LIMIT="$1"
                                shift
                            else
                                break
                            fi
                            ;;
                    esac
                done
                break
                ;;
            -*)
                print_colored "$RED" "[!]" "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
            *)
                # Try to parse as port or port range
                if parsed_ports=$(parse_port_range "$1" 2>/dev/null); then
                    read -ra range_ports <<< "$parsed_ports"
                    ports+=("${range_ports[@]}")
                else
                    command="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Handle remaining arguments differently based on command
    if [[ "$command" == "benchmark" ]]; then
        # For benchmark: port [host] [count]
        while [[ $# -gt 0 ]]; do
            if [[ ${#ports[@]} -eq 0 ]]; then
                # First argument should be port
                if parsed_ports=$(parse_port_range "$1" 2>/dev/null); then
                    read -ra range_ports <<< "$parsed_ports"
                    ports+=("${range_ports[@]}")
                else
                    print_colored "$RED" "[!]" "Invalid port: $1"
                    exit 1
                fi
            else
                # Additional arguments for benchmark (host, count)
                ports+=("$1")
            fi
            shift
        done
    else
        # For other commands: parse as ports/ranges
        while [[ $# -gt 0 ]]; do
            if parsed_ports=$(parse_port_range "$1"); then
                read -ra range_ports <<< "$parsed_ports"
                ports+=("${range_ports[@]}")
            else
                print_colored "$RED" "[!]" "Invalid port or range: $1"
                exit 1
            fi
            shift
        done
    fi
    
    case "$command" in
        list)
            if [[ ${#ports[@]} -eq 0 ]]; then
                list_all_listening_ports
            else
                for port in "${ports[@]}"; do
                    list_processes "$port" "${DETAILED_MODE:-false}"
                    add_to_history "LIST" "Port: $port, Detailed: ${DETAILED_MODE:-false}"
                done
            fi
            ;;
        kill)
            if [[ ${#ports[@]} -eq 0 ]]; then
                print_colored "$RED" "[!]" "No ports specified for kill command"
                exit 1
            fi
            
            if [[ ${#ports[@]} -gt 1 ]]; then
                bulk_kill_ports "${ports[@]}"
            else
                kill_processes "${ports[0]}" "${FORCE_MODE:-false}" "${DRY_RUN_MODE:-false}" "${INTERACTIVE_MODE:-false}"
            fi
            ;;
        monitor)
            if [[ ${#ports[@]} -eq 0 ]]; then
                print_colored "$RED" "[!]" "No ports specified for monitoring"
                exit 1
            fi
            monitor_ports "${ports[@]}"
            ;;
        tree)
            if [[ ${#ports[@]} -eq 0 ]]; then
                print_colored "$RED" "[!]" "No port specified for process tree"
                exit 1
            fi
            
            # Process tree depth option
            local tree_depth=5
            if [[ -n "$TREE_DEPTH" ]]; then
                tree_depth="$TREE_DEPTH"
            fi
            
            for port in "${ports[@]}"; do
                show_process_tree "$port" "$tree_depth"
            done
            ;;
        scan)
            if [[ "$SECURITY_SCAN" == "true" ]]; then
                security_scan
            else
                list_all_listening_ports
            fi
            add_to_history "SCAN" "Type: ${SECURITY_SCAN:+security}"
            ;;
        menu)
            INTERACTIVE_MODE=true
            interactive_menu
            ;;
        benchmark)
            if [[ ${#ports[@]} -eq 0 ]]; then
                print_colored "$RED" "[!]" "No port specified for benchmark"
                exit 1
            fi
            
            # Parse benchmark arguments: port [host] [count]
            local port="${ports[0]}"
            local host="localhost"
            local test_count="10"
            
            # Second argument is host (if provided)
            if [[ ${#ports[@]} -gt 1 ]]; then
                host="${ports[1]}"
            fi
            
            # Third argument is test count (if provided and numeric)
            if [[ ${#ports[@]} -gt 2 && "${ports[2]}" =~ ^[0-9]+$ ]]; then
                test_count="${ports[2]}"
            fi
            
            benchmark_port "$port" "$host" "$test_count"
            ;;
        history)
            if [[ "$HISTORY_ANALYTICS" == "true" ]]; then
                show_port_analytics
            elif [[ "$HISTORY_FORMAT" == "csv" ]]; then
                show_port_history "$HISTORY_LIMIT" "csv"
            elif [[ "$HISTORY_EXPORT" == "true" ]]; then
                export_history "" "${HISTORY_EXPORT_FORMAT:-csv}"
            elif [[ "$HISTORY_CLEAR" == "true" ]]; then
                clear_history "${HISTORY_KEEP:-100}"
            else
                show_port_history "$HISTORY_LIMIT"
            fi
            ;;
        "")
            if [[ ${#ports[@]} -gt 0 ]]; then
                # Default behavior: kill processes on specified ports
                if [[ ${#ports[@]} -gt 1 ]]; then
                    bulk_kill_ports "${ports[@]}"
                else
                    kill_processes "${ports[0]}" "${FORCE_MODE:-false}" "${DRY_RUN_MODE:-false}" "${INTERACTIVE_MODE:-false}"
                fi
            else
                INTERACTIVE_MODE=true
                interactive_menu
            fi
            ;;
        *)
            print_colored "$RED" "[!]" "Unknown command: $command"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
    
    log_message "INFO" "PortKill operation completed"
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    local required_commands=("lsof" "ps" "kill" "netstat")
    local optional_commands=("bc" "nc")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_colored "$RED" "[!]" "Missing required commands: ${missing[*]}"
        echo "Please install missing dependencies and try again"
        exit 1
    fi
    
    # Check optional commands and warn if missing
    local missing_optional=()
    for cmd in "${optional_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_optional+=("$cmd")
        fi
    done
    
    if [[ ${#missing_optional[@]} -gt 0 ]] && [[ "$VERBOSE_MODE" == "true" ]]; then
        print_colored "$YELLOW" "[!]" "Optional commands not found: ${missing_optional[*]}"
        print_colored "$YELLOW" "[i]" "Some features may have reduced functionality"
    fi
}

# Signal handlers
setup_signal_handlers() {
    trap cleanup_on_exit EXIT
    trap handle_interrupt INT
}

cleanup_on_exit() {
    log_message "INFO" "PortKill session ended"
}

handle_interrupt() {
    echo
    print_colored "$YELLOW" "[i]" "Operation interrupted by user"
    log_message "INFO" "Operation interrupted by user"
    exit 130
}

# Check platform
if [[ "$OSTYPE" != "darwin"* ]] && [[ "$OSTYPE" != "linux"* ]]; then
    print_colored "$RED" "[!]" "This tool is designed for macOS and Linux"
    exit 1
fi

setup_signal_handlers
check_dependencies
main "$@"